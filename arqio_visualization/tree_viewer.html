<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>LangExtract Tree Viewer</title>
  <style>
    :root {
      --bg: #0f172a; /* slate-900 */
      --panel: #111827; /* gray-900 */
      --muted: #9ca3af; /* gray-400 */
      --text: #e5e7eb; /* gray-200 */
      --accent: #22c55e; /* green-500 */
      --accent2: #60a5fa; /* blue-400 */
      --warn: #f59e0b; /* amber-500 */
      --error: #ef4444; /* red-500 */
      --chip: #374151; /* gray-700 */
      --border: #334155; /* slate-700 */
    }
    html, body { height: 100%; }
    body {
      margin: 0; background: var(--bg); color: var(--text); font-family: ui-sans-serif, system-ui, -apple-system,
      Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
    }
    header {
      display: flex; gap: 12px; align-items: center; padding: 16px; border-bottom: 1px solid var(--border);
      position: sticky; top: 0; background: rgba(15,23,42,0.9); backdrop-filter: blur(8px); z-index: 10;
    }
    header h1 { font-size: 18px; margin: 0 8px 0 0; font-weight: 600; }
    header .spacer { flex: 1; }
    button, select, input[type="text"], input[type="file"] {
      background: var(--panel); color: var(--text); border: 1px solid var(--border); border-radius: 8px;
      padding: 8px 10px; font-size: 14px;
    }
    button { cursor: pointer; }
    button.primary { background: linear-gradient(135deg, #059669, #16a34a, #22c55e); border-color: #065f46; }
    button.ghost { background: transparent; }
    button:hover { background: var(--chip); }
    button.primary:hover { background: linear-gradient(135deg, #047857, #15803d, #16a34a); }
    input[type="file"] { cursor: pointer; }
    main { padding: 16px; }
    
    .file-selector {
      background: var(--panel); border: 1px solid var(--border); border-radius: 12px; 
      padding: 16px; margin-bottom: 16px; text-align: center;
    }
    
    .controls {
      display: flex; gap: 8px; flex-wrap: wrap; margin-bottom: 16px; padding: 16px;
      background: var(--panel); border: 1px solid var(--border); border-radius: 12px;
    }
    
    .tree-container {
      background: var(--panel); border: 1px solid var(--border); border-radius: 12px;
      padding: 20px; min-height: 600px; overflow: auto;
    }
    
    .tree-node {
      margin: 4px 0;
      position: relative;
    }
    
    .tree-node.collapsed > .tree-children {
      display: none;
    }
    
    .tree-item {
      display: flex;
      align-items: flex-start;
      padding: 12px;
      margin: 2px 0;
      background: linear-gradient(180deg, rgba(17,24,39,0.8), rgba(2,6,23,0.8));
      border: 1px solid var(--border);
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.3s ease;
      position: relative;
    }
    
    .tree-item:hover {
      background: linear-gradient(180deg, rgba(55,65,81,0.8), rgba(17,24,39,0.8));
      border-color: var(--accent);
      transform: translateX(2px);
    }
    
    .tree-item.has-children::before {
      content: '▼';
      margin-right: 8px;
      font-size: 12px;
      color: var(--muted);
      transition: transform 0.3s ease;
      flex-shrink: 0;
      margin-top: 2px;
    }
    
    .tree-node.collapsed .tree-item.has-children::before {
      transform: rotate(-90deg);
    }
    
    .node-content {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    
    .node-header {
      display: flex;
      align-items: center;
      gap: 12px;
      flex-wrap: wrap;
    }
    
    .node-id {
      font-family: ui-monospace, monospace;
      font-size: 12px;
      color: var(--muted);
      background: var(--chip);
      padding: 2px 6px;
      border-radius: 4px;
      flex-shrink: 0;
    }
    
    .node-type {
      display: inline-block;
      padding: 4px 8px;
      border-radius: 12px;
      font-size: 11px;
      font-weight: bold;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      flex-shrink: 0;
    }
    
    .node-title {
      font-weight: 600;
      color: var(--text);
      flex: 1;
      word-break: break-word;
    }
    
    .node-details {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
      gap: 12px;
      margin-top: 8px;
    }
    
    .detail-group {
      background: rgba(55,65,81,0.3);
      border: 1px solid var(--border);
      border-radius: 6px;
      padding: 12px;
    }
    
    .detail-group h4 {
      margin: 0 0 8px 0;
      font-size: 12px;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    
    .detail-item {
      margin: 6px 0;
      font-size: 14px;
    }
    
    .detail-label {
      color: var(--muted);
      font-size: 12px;
      margin-bottom: 2px;
    }
    
    .detail-value {
      color: var(--text);
      word-break: break-word;
    }
    
    .pill {
      padding: 2px 8px;
      border-radius: 999px;
      border: 1px solid var(--border);
      font-size: 12px;
      display: inline-block;
      margin: 2px 4px 2px 0;
    }
    
    .pill.mandatory { background: rgba(34,197,94,0.1); border-color: #14532d; color: #86efac; }
    .pill.permission { background: rgba(96,165,250,0.1); border-color: #1e3a8a; color: #bfdbfe; }
    .pill.prohibition { background: rgba(239,68,68,0.1); border-color: #7f1d1d; color: #fecaca; }
    
    .tree-children {
      margin-left: 20px;
      border-left: 2px solid var(--border);
      padding-left: 15px;
      margin-top: 8px;
    }
    
    /* Type-specific colors */
    .type-SECTION { border-left: 4px solid #667eea; }
    .type-SECTION .node-type { background: #667eea; color: white; }
    
    .type-NORM { border-left: 4px solid #ff9800; }
    .type-NORM .node-type { background: #ff9800; color: white; }
    
    .type-TABLE { border-left: 4px solid #e91e63; }
    .type-TABLE .node-type { background: #e91e63; color: white; }
    
    .type-LEGAL_DOCUMENT { border-left: 4px solid #795548; }
    .type-LEGAL_DOCUMENT .node-type { background: #795548; color: white; }
    
    .type-PROCEDURE { border-left: 4px solid #9c27b0; }
    .type-PROCEDURE .node-type { background: #9c27b0; color: white; }
    
    .type-PARAMETER { border-left: 4px solid #00bcd4; }
    .type-PARAMETER .node-type { background: #00bcd4; color: white; }
    
    .type-TAG { border-left: 4px solid #4caf50; }
    .type-TAG .node-type { background: #4caf50; color: white; }
    
    .type-QUESTION { border-left: 4px solid #ffc107; }
    .type-QUESTION .node-type { background: #ffc107; color: black; }
    
    .hidden { display: none; }
    .muted { color: var(--muted); }
    .mono { font-family: ui-monospace, monospace; }
    
    .stats-summary {
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 16px;
      margin-bottom: 16px;
      text-align: center;
    }
    
    .stats-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
      gap: 16px;
      margin-top: 12px;
    }
    
    .stat-item {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }
    
    .stat-number {
      font-size: 24px;
      font-weight: bold;
      color: var(--accent);
    }
    
    .stat-label {
      color: var(--muted);
      font-size: 12px;
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    
    /* Responsive design */
    @media (max-width: 768px) {
      .controls { flex-direction: column; }
      .tree-children { margin-left: 10px; padding-left: 10px; }
      .node-details { grid-template-columns: 1fr; }
    }
  </style>
</head>
<body>
  <header>
    <h1>LangExtract Tree Viewer</h1>
    <span class="muted">Hierarchical document structure</span>
    <div class="spacer"></div>
    <button id="exportCsv" class="ghost">Export CSV</button>
    <button id="reloadBtn" class="ghost">Reload</button>
  </header>

  <main>
    <div class="file-selector">
      <h3>Select JSON File</h3>
      <input id="fileInput" type="file" accept="application/json" />
      <p class="muted">Choose an annotated_extractions_single.json file to visualize</p>
    </div>

    <div id="stats" class="stats-summary hidden">
      <h3>Document Statistics</h3>
      <div class="stats-grid">
        <div class="stat-item">
          <div id="totalItems" class="stat-number">0</div>
          <div class="stat-label">Total Items</div>
        </div>
        <div class="stat-item">
          <div id="sectionsCount" class="stat-number">0</div>
          <div class="stat-label">Sections</div>
        </div>
        <div class="stat-item">
          <div id="normsCount" class="stat-number">0</div>
          <div class="stat-label">Norms</div>
        </div>
        <div class="stat-item">
          <div id="tablesCount" class="stat-number">0</div>
          <div class="stat-label">Tables</div>
        </div>
        <div class="stat-item">
          <div id="docsCount" class="stat-number">0</div>
          <div class="stat-label">Legal Docs</div>
        </div>
        <div class="stat-item">
          <div id="levelsCount" class="stat-number">0</div>
          <div class="stat-label">Max Depth</div>
        </div>
      </div>
    </div>

    <div id="controls" class="controls hidden">
      <button class="primary" onclick="expandAll()">Expand All</button>
      <button class="primary" onclick="collapseAll()">Collapse All</button>
      <button class="ghost" onclick="filterByType('SECTION')">Sections Only</button>
      <button class="ghost" onclick="filterByType('NORM')">Norms Only</button>
      <button class="ghost" onclick="filterByType('TABLE')">Tables Only</button>
      <button class="ghost" onclick="filterByType('LEGAL_DOCUMENT')">Legal Docs Only</button>
      <button class="ghost" onclick="showAll()">Show All</button>
      <button class="ghost" onclick="toggleDetails()">Toggle Details</button>
    </div>

    <div id="tree-container" class="tree-container">
      <div class="muted" style="text-align: center; padding: 40px;">
        Select a JSON file to display the document tree structure
      </div>
    </div>
  </main>

  <script>
    let treeData = null;
    let showDetails = true;
    let currentFilter = null;

    function byId(id) { return document.getElementById(id); }
    function setText(id, text) { const el = byId(id); if (el) el.textContent = text; }
    
    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    function formatValue(value) {
      if (value == null || value === '') return '<em class="muted">—</em>';
      if (typeof value === 'string') return escapeHtml(value);
      if (typeof value === 'number' || typeof value === 'boolean') return String(value);
      if (Array.isArray(value)) {
        if (value.length === 0) return '<em class="muted">—</em>';
        return value.map(v => `<span class="pill">${escapeHtml(String(v))}</span>`).join('');
      }
      if (typeof value === 'object') {
        return '<em class="muted">[object]</em>';
      }
      return escapeHtml(String(value));
    }

    function obligationPill(type) {
      const t = (type || '').toUpperCase();
      const cls = t === 'MANDATORY' ? 'mandatory' : t === 'PROHIBITION' ? 'prohibition' : 'permission';
      const label = t || 'UNKNOWN';
      return `<span class="pill ${cls}">${label}</span>`;
    }

    function buildTree(items) {
      if (!Array.isArray(items)) return [];
      
      console.log('Building tree from', items.length, 'items');
      
      // Filter relevant extraction types like the Python script does
      const relevantTypes = ['SECTION', 'NORM', 'TABLE', 'LEGAL_DOCUMENT'];
      const relevantItems = items.filter(item => 
        item && relevantTypes.includes(item.extraction_class)
      );
      
      console.log('Filtered to', relevantItems.length, 'relevant items');
      
      // Count types for verification
      const typeCounts = {};
      relevantItems.forEach(item => {
        const type = item.extraction_class;
        typeCounts[type] = (typeCounts[type] || 0) + 1;
      });
      console.log('Type counts:', typeCounts);
      
      // Create a map for quick lookup - use a new Map each time to prevent contamination
      const itemMap = new Map();
      const rootItems = [];
      
      // First pass: normalize and create all items (matching Python logic)
      const createdItems = new Set(); // Track which items we've already created
      
      relevantItems.forEach((item, index) => {
        if (!item || !item.attributes) return;
        
        const attributes = item.attributes;
        const extraction_class = item.extraction_class;
        const id = attributes.id;
        
        // Skip if we've already processed this ID
        if (!id || createdItems.has(id)) {
          if (!id) console.warn('Item without ID at index', index);
          else console.warn('Duplicate item ID found:', id);
          return;
        }
        
        createdItems.add(id);
        
        // Build normalized item following Python _create_node logic
        // Create a fresh object to avoid reference issues
        let normalizedItem = {
          id: id,
          extraction_class: extraction_class,
          children: [],
          originalIndex: index,
          extraction_text: item.extraction_text || '',
          extraction_index: item.extraction_index
        };
        
        // Handle different extraction types like Python script
        if (extraction_class === 'SECTION') {
          normalizedItem.section_title = attributes.section_title || '';
          normalizedItem.sectioning_type = attributes.sectioning_type || 'Section';
          normalizedItem.parent_id = attributes.parent_id;
          normalizedItem.section_summary = attributes.section_summary || '';
        } 
        else if (extraction_class === 'NORM') {
          const statement = attributes.norm_statement || '';
          normalizedItem.norm_statement = statement;
          normalizedItem.section_title = statement.length > 100 ? statement.substring(0, 100) + '...' : statement;
          normalizedItem.sectioning_type = 'NORM';
          // Use parent_section_id for NORM objects
          normalizedItem.parent_id = attributes.parent_section_id || attributes.parent_id;
          normalizedItem.section_summary = `Paragraph ${attributes.paragraph_number || 'N/A'} - ${attributes.obligation_type || 'Unknown'}`;
          normalizedItem.obligation_type = attributes.obligation_type;
          normalizedItem.paragraph_number = attributes.paragraph_number;
        }
        else if (extraction_class === 'TABLE') {
          normalizedItem.section_title = attributes.table_title || item.extraction_text?.substring(0, 50) || '';
          normalizedItem.sectioning_type = 'Table';
          // Use parent_section_id for TABLE objects  
          normalizedItem.parent_id = attributes.parent_section_id || attributes.parent_id;
          normalizedItem.section_summary = attributes.table_description || '';
        }
        else if (extraction_class === 'LEGAL_DOCUMENT') {
          normalizedItem.section_title = attributes.doc_title || attributes.title || '';
          normalizedItem.sectioning_type = 'Legal Document';
          normalizedItem.parent_id = attributes.parent_id;
          normalizedItem.section_summary = `${attributes.doc_type || 'Document'} - ${attributes.jurisdiction || 'Unknown jurisdiction'}`;
          normalizedItem.doc_title = attributes.doc_title;
          normalizedItem.citation = attributes.citation;
          normalizedItem.jurisdiction = attributes.jurisdiction;
        }
        
        // Flatten additional attributes - create new properties to avoid reference issues
        Object.keys(attributes).forEach(key => {
          if (!normalizedItem.hasOwnProperty(key)) {
            normalizedItem[key] = attributes[key];
          }
        });
        
        itemMap.set(id, normalizedItem);
      });
      
      console.log('Created item map with', itemMap.size, 'items');
      console.log('Processed', createdItems.size, 'unique items in first pass');
      
      // Second pass: build hierarchy (matching Python _build_tree logic)
      const processedItems = new Set(); // Track which items we've already processed
      
      relevantItems.forEach((item, index) => {
        if (!item || !item.attributes) return;
        
        const id = item.attributes.id;
        if (!id || processedItems.has(id)) return; // Skip if already processed
        
        processedItems.add(id);
        
        const treeItem = itemMap.get(id);
        if (!treeItem) return;
        
        if (!treeItem.parent_id || !itemMap.has(treeItem.parent_id)) {
          // Root node - check if it's already in rootItems
          if (!rootItems.find(root => root.id === id)) {
            rootItems.push(treeItem);
          }
        } else {
          // Child node - add to parent
          const parent = itemMap.get(treeItem.parent_id);
          if (parent) {
            // Check if this child is already in parent's children
            if (!parent.children.find(child => child.id === id)) {
              parent.children.push(treeItem);
            }
          } else {
            // Parent not found, make it a root node if not already there
            if (!rootItems.find(root => root.id === id)) {
              rootItems.push(treeItem);
            }
          }
        }
      });
      
      console.log('Built tree with', rootItems.length, 'root items');
      console.log('Processed', processedItems.size, 'unique items');
      
      // Check if we need to create a synthetic CTE.DB.SI root node
      const cteDbSiId = 'CTE.DB.SI';
      if (!itemMap.has(cteDbSiId)) {
        // Check if any items have CTE.DB.SI as parent_id
        const hasCteChildren = rootItems.some(item => 
          item.parent_id === cteDbSiId || 
          [...itemMap.values()].some(node => node.parent_id === cteDbSiId)
        );
        
        if (hasCteChildren) {
          console.log('Creating synthetic root node for', cteDbSiId);
          // Create synthetic root node
          const syntheticRoot = {
            id: cteDbSiId,
            section_title: 'CTE DB-SI - Documento Básico de Seguridad en caso de Incendio',
            extraction_class: 'LEGAL_DOCUMENT',
            parent_id: null,
            children: [],
            extraction_text: 'Código Técnico de la Edificación - Documento Básico de Seguridad en caso de Incendio',
            sectioning_type: 'Legal Document',
            extraction_index: -1
          };
          
          itemMap.set(cteDbSiId, syntheticRoot);
          
          // Move items that have CTE.DB.SI as parent to this synthetic root
          const itemsToMove = [...itemMap.values()].filter(item => 
            item.parent_id === cteDbSiId && item.id !== cteDbSiId
          );
          
          itemsToMove.forEach(item => {
            // Remove from rootItems if it's there
            const rootIndex = rootItems.findIndex(root => root.id === item.id);
            if (rootIndex !== -1) {
              rootItems.splice(rootIndex, 1);
            }
            // Add to synthetic root's children
            if (!syntheticRoot.children.find(child => child.id === item.id)) {
              syntheticRoot.children.push(item);
            }
          });
          
          rootItems.unshift(syntheticRoot); // Add at the beginning
          console.log('Added synthetic root with', syntheticRoot.children.length, 'children');
        }
      }
      
      // Verify no duplicate IDs in root items
      const rootIds = new Set();
      const duplicateRoots = [];
      rootItems.forEach(item => {
        if (rootIds.has(item.id)) {
          duplicateRoots.push(item.id);
        }
        rootIds.add(item.id);
      });
      if (duplicateRoots.length > 0) {
        console.warn('Duplicate root items found:', duplicateRoots);
      }
      
      // Sort items by extraction_index for consistent ordering
      const sortItems = (items) => {
        items.sort((a, b) => {
          const aIndex = a.extraction_index || a.originalIndex || 0;
          const bIndex = b.extraction_index || b.originalIndex || 0;
          return aIndex - bIndex;
        });
        items.forEach(item => {
          if (item.children && item.children.length > 0) {
            sortItems(item.children);
          }
        });
      };
      
      sortItems(rootItems);
      
      return rootItems;
    }

    function renderTreeNode(item, level = 0, maxDepth = 20) {
      // Prevent infinite recursion by limiting depth
      if (level > maxDepth) {
        console.warn('Maximum tree depth exceeded, stopping recursion at level', level);
        return '<div class="tree-node"><div class="tree-item"><span class="muted">Maximum depth exceeded...</span></div></div>';
      }
      
      if (!item || !item.id) {
        console.warn('Invalid item at level', level, item);
        return '';
      }
      
      const hasChildren = item.children && item.children.length > 0;
      const nodeClass = hasChildren ? 'has-children' : '';
      const typeClass = `type-${item.extraction_class || 'UNKNOWN'}`;
      
      let html = `<div class="tree-node" data-level="${level}" data-type="${item.extraction_class || 'UNKNOWN'}">`;
      html += `<div class="tree-item ${nodeClass} ${typeClass}" onclick="toggleNode(this)">`;
      
      html += `<div class="node-content">`;
      html += `<div class="node-header">`;
      html += `<span class="node-id">${escapeHtml(item.id || '')}</span>`;
      html += `<span class="node-type">${item.extraction_class || 'UNKNOWN'}</span>`;
      html += `<span class="node-title">${getTitle(item)}</span>`;
      html += `</div>`;
      
      if (showDetails) {
        html += renderNodeDetails(item);
      }
      
      html += `</div>`;
      html += `</div>`;
      
      if (hasChildren && level < maxDepth) {
        html += `<div class="tree-children">`;
        item.children.forEach((child, index) => {
          if (index > 1000) { // Safety limit for children
            html += '<div class="muted" style="padding: 10px;">... and more items (truncated for performance)</div>';
            return;
          }
          html += renderTreeNode(child, level + 1, maxDepth);
        });
        html += `</div>`;
      }
      
      html += `</div>`;
      return html;
    }

    function getTitle(item) {
      // Use the section_title that was set during normalization
      if (item.section_title && item.section_title.trim()) {
        return escapeHtml(item.section_title);
      }
      
      // Fallback to other title fields
      if (item.doc_title) return escapeHtml(item.doc_title);
      if (item.title) return escapeHtml(item.title);
      
      // For extraction_text, clean up markdown headers
      if (item.extraction_text) {
        let text = item.extraction_text.trim();
        text = text.replace(/^#{1,6}\s*/, ''); // Remove markdown headers
        text = text.replace(/\n.*$/s, ''); // Take only first line
        if (text) {
          return escapeHtml(text.length > 100 ? text.substring(0, 100) + '...' : text);
        }
      }
      
      // Fallback to other text fields
      if (item.norm_statement) {
        const statement = item.norm_statement.trim();
        return escapeHtml(statement.length > 80 ? statement.substring(0, 80) + '...' : statement);
      }
      
      if (item.statement_text) return escapeHtml(item.statement_text.substring(0, 80) + (item.statement_text.length > 80 ? '...' : ''));
      if (item.text) return escapeHtml(item.text.substring(0, 80) + (item.text.length > 80 ? '...' : ''));
      
      return `<em class="muted">${item.extraction_class || 'Unknown'} - No title available</em>`;
    }

    function renderNodeDetails(item) {
      let html = `<div class="node-details">`;
      
      // Basic info
      const basicInfo = [];
      if (item.extraction_text) basicInfo.push(['Extraction Text', item.extraction_text]);
      if (item.norm_statement && item.extraction_class === 'NORM') basicInfo.push(['Statement', item.norm_statement]);
      if (item.section_summary) basicInfo.push(['Summary', item.section_summary]);
      if (item.notes) basicInfo.push(['Notes', item.notes]);
      if (item.description) basicInfo.push(['Description', item.description]);
      
      if (basicInfo.length > 0) {
        html += `<div class="detail-group">`;
        html += `<h4>Basic Information</h4>`;
        basicInfo.forEach(([label, value]) => {
          html += `<div class="detail-item">`;
          html += `<div class="detail-label">${label}</div>`;
          html += `<div class="detail-value">${formatValue(value)}</div>`;
          html += `</div>`;
        });
        html += `</div>`;
      }
      
      // Type-specific details
      if (item.extraction_class === 'NORM') {
        const normInfo = [];
        if (item.obligation_type) normInfo.push(['Type', obligationPill(item.obligation_type)]);
        if (item.priority !== undefined && item.priority !== null) normInfo.push(['Priority', item.priority]);
        if (item.applies_if) normInfo.push(['Applies If', item.applies_if]);
        if (item.satisfied_if) normInfo.push(['Satisfied If', item.satisfied_if]);
        if (item.exempt_if) normInfo.push(['Exempt If', item.exempt_if]);
        
        if (normInfo.length > 0) {
          html += `<div class="detail-group">`;
          html += `<h4>Norm Details</h4>`;
          normInfo.forEach(([label, value]) => {
            html += `<div class="detail-item">`;
            html += `<div class="detail-label">${label}</div>`;
            html += `<div class="detail-value">${typeof value === 'string' && value.includes('pill') ? value : formatValue(value)}</div>`;
            html += `</div>`;
          });
          html += `</div>`;
        }
      }
      
      if (item.extraction_class === 'SECTION') {
        const sectionInfo = [];
        if (item.sectioning_type) sectionInfo.push(['Section Type', item.sectioning_type]);
        if (item.section_level) sectionInfo.push(['Level', item.section_level]);
        if (item.parent_type) sectionInfo.push(['Parent Type', item.parent_type]);
        if (item.author) sectionInfo.push(['Author', item.author]);
        if (item.date) sectionInfo.push(['Date', item.date]);
        if (item.source) sectionInfo.push(['Source', item.source]);
        
        if (sectionInfo.length > 0) {
          html += `<div class="detail-group">`;
          html += `<h4>Section Details</h4>`;
          sectionInfo.forEach(([label, value]) => {
            html += `<div class="detail-item">`;
            html += `<div class="detail-label">${label}</div>`;
            html += `<div class="detail-value">${formatValue(value)}</div>`;
            html += `</div>`;
          });
          html += `</div>`;
        }
      }
      
      if (item.extraction_class === 'LEGAL_DOCUMENT') {
        const legalInfo = [];
        if (item.citation) legalInfo.push(['Citation', item.citation]);
        if (item.jurisdiction) legalInfo.push(['Jurisdiction', item.jurisdiction]);
        if (item.doc_type) legalInfo.push(['Document Type', item.doc_type]);
        if (item.url) legalInfo.push(['URL', item.url]);
        if (item.article) legalInfo.push(['Article', item.article]);
        if (item.section) legalInfo.push(['Section', item.section]);
        
        if (legalInfo.length > 0) {
          html += `<div class="detail-group">`;
          html += `<h4>Legal Document Details</h4>`;
          legalInfo.forEach(([label, value]) => {
            html += `<div class="detail-item">`;
            html += `<div class="detail-label">${label}</div>`;
            html += `<div class="detail-value">${formatValue(value)}</div>`;
            html += `</div>`;
          });
          html += `</div>`;
        }
      }
      
      // Position and indexing info
      const positionInfo = [];
      if (item.extraction_index) positionInfo.push(['Extraction Index', item.extraction_index]);
      if (item.group_index !== undefined) positionInfo.push(['Group Index', item.group_index]);
      if (item.char_interval) {
        positionInfo.push(['Character Range', `${item.char_interval.start_pos}-${item.char_interval.end_pos}`]);
      }
      if (item.alignment_status) positionInfo.push(['Alignment Status', item.alignment_status]);
      
      if (positionInfo.length > 0) {
        html += `<div class="detail-group">`;
        html += `<h4>Position Information</h4>`;
        positionInfo.forEach(([label, value]) => {
          html += `<div class="detail-item">`;
          html += `<div class="detail-label">${label}</div>`;
          html += `<div class="detail-value">${formatValue(value)}</div>`;
          html += `</div>`;
        });
        html += `</div>`;
      }
      
      // Original attributes (if any additional ones exist)
      if (item.attributes && Object.keys(item.attributes).length > 0) {
        // Only show attributes that weren't already flattened
        const remainingAttrs = {};
        Object.entries(item.attributes).forEach(([key, value]) => {
          if (!item.hasOwnProperty(key)) {
            remainingAttrs[key] = value;
          }
        });
        
        if (Object.keys(remainingAttrs).length > 0) {
          html += `<div class="detail-group">`;
          html += `<h4>Additional Attributes</h4>`;
          Object.entries(remainingAttrs).forEach(([key, value]) => {
            html += `<div class="detail-item">`;
            html += `<div class="detail-label">${escapeHtml(key)}</div>`;
            html += `<div class="detail-value">${formatValue(value)}</div>`;
            html += `</div>`;
          });
          html += `</div>`;
        }
      }
      
      html += `</div>`;
      return html;
    }

    function updateStats(tree) {
      const stats = { total: 0, sections: 0, norms: 0, tables: 0, docs: 0, maxDepth: 0 };
      
      // Use a single Set to track all visited items across the entire tree
      const globalVisited = new Set();
      
      function countItems(items, depth = 0) {
        if (depth > 50) { // Safety limit
          console.warn('Maximum depth reached in stats calculation');
          return;
        }
        
        stats.maxDepth = Math.max(stats.maxDepth, depth);
        
        items.forEach(item => {
          if (!item || !item.id) return;
          
          // Prevent counting the same item multiple times
          if (globalVisited.has(item.id)) {
            console.warn('Item already counted, skipping:', item.id);
            return;
          }
          globalVisited.add(item.id);
          
          stats.total++;
          const type = item.extraction_class;
          if (type === 'SECTION') stats.sections++;
          else if (type === 'NORM') stats.norms++;
          else if (type === 'TABLE') stats.tables++;
          else if (type === 'LEGAL_DOCUMENT') stats.docs++;
          
          if (item.children && item.children.length > 0) {
            countItems(item.children, depth + 1);
          }
        });
      }
      
      try {
        countItems(tree);
        
        // Log stats for verification
        console.log('Statistics calculated:', stats);
        console.log('Total unique items processed:', globalVisited.size);
        
      } catch (error) {
        console.error('Error calculating stats:', error);
        // Set safe defaults
        stats.total = tree.length;
        stats.maxDepth = 1;
      }
      
      setText('totalItems', stats.total);
      setText('sectionsCount', stats.sections);
      setText('normsCount', stats.norms);
      setText('tablesCount', stats.tables);
      setText('docsCount', stats.docs);
      setText('levelsCount', stats.maxDepth + 1);
    }

    function toggleNode(element) {
      const node = element.closest('.tree-node');
      node.classList.toggle('collapsed');
    }

    function expandAll() {
      document.querySelectorAll('.tree-node').forEach(node => {
        node.classList.remove('collapsed');
      });
    }

    function collapseAll() {
      document.querySelectorAll('.tree-node').forEach(node => {
        if (node.querySelector('.tree-children')) {
          node.classList.add('collapsed');
        }
      });
    }

    function filterByType(type) {
      currentFilter = type;
      const nodes = document.querySelectorAll('.tree-node');
      nodes.forEach(node => {
        const nodeType = node.getAttribute('data-type');
        if (nodeType === type) {
          node.style.display = 'block';
          showParents(node);
        } else {
          node.style.display = 'none';
        }
      });
    }

    function showAll() {
      currentFilter = null;
      document.querySelectorAll('.tree-node').forEach(node => {
        node.style.display = 'block';
      });
    }

    function showParents(element) {
      let parent = element.parentElement;
      while (parent && parent.classList.contains('tree-children')) {
        const parentNode = parent.parentElement;
        if (parentNode && parentNode.classList.contains('tree-node')) {
          parentNode.style.display = 'block';
          parent = parentNode.parentElement;
        } else {
          break;
        }
      }
    }

    function toggleDetails() {
      showDetails = !showDetails;
      if (treeData) {
        renderTree();
      }
    }

    function renderTree() {
      const container = byId('tree-container');
      
      if (!treeData) {
        container.innerHTML = '<div class="muted" style="text-align: center; padding: 40px;">No tree data available - please select a JSON file</div>';
        // Hide controls and stats when no data
        byId('stats').classList.add('hidden');
        byId('controls').classList.add('hidden');
        return;
      }
      
      if (!Array.isArray(treeData) || treeData.length === 0) {
        container.innerHTML = '<div class="muted" style="text-align: center; padding: 40px;">No root items found in the data structure</div>';
        console.log('Tree data issue:', treeData);
        // Hide controls and stats when no data
        byId('stats').classList.add('hidden');
        byId('controls').classList.add('hidden');
        return;
      }
      
      console.log('Rendering tree with', treeData.length, 'root items');
      
      // Clear container before rendering to prevent duplication
      container.innerHTML = '';
      
      let html = '';
      treeData.forEach((item, index) => {
        console.log(`Rendering root item ${index}:`, item);
        html += renderTreeNode(item);
      });
      
      if (!html.trim()) {
        container.innerHTML = '<div class="muted" style="text-align: center; padding: 40px;">Failed to render tree nodes</div>';
        return;
      }
      
      container.innerHTML = html;
      updateStats(treeData);
      
      // Show controls and stats
      byId('stats').classList.remove('hidden');
      byId('controls').classList.remove('hidden');
      
      console.log('Tree rendering complete');
    }

    function processJSONData(jsonData) {
      console.log('Processing JSON data:', jsonData);
      
      if (!jsonData) {
        alert('No JSON data provided.');
        return;
      }
      
      if (!jsonData.extractions) {
        alert('Invalid JSON format. Expected "extractions" array.');
        return;
      }
      
      console.log('Found extractions:', jsonData.extractions.length);
      
      // Clear any existing data to prevent duplication
      treeData = null;
      currentFilter = null;
      
      // Log a sample of different extraction types for debugging
      const samplesByType = {};
      jsonData.extractions.forEach(ext => {
        const type = ext?.extraction_class;
        if (type && !samplesByType[type]) {
          samplesByType[type] = ext;
        }
      });
      console.log('Sample extractions by type:', samplesByType);
      
      treeData = buildTree(jsonData.extractions);
      console.log('Built tree data:', treeData);
      console.log('Root items count:', treeData.length);
      
      if (treeData.length === 0) {
        console.warn('No root items found - check parent-child relationships');
      }
      
      renderTree();
    }

    function exportCsv() {
      if (!treeData) return;
      
      const flattenTree = (items, result = []) => {
        items.forEach(item => {
          result.push(item);
          if (item.children && item.children.length > 0) {
            flattenTree(item.children, result);
          }
        });
        return result;
      };
      
      const allItems = flattenTree(treeData);
      const csvRows = [['ID', 'Type', 'Title', 'Parent ID', 'Text', 'Section Level', 'Extraction Index']];
      
      allItems.forEach(item => {
        csvRows.push([
          item.id || '',
          item.extraction_class || '',
          getTitle(item).replace(/<[^>]*>/g, ''),
          item.parent_id || item.parent_section_id || '',
          (item.extraction_text || '').replace(/"/g, '""'),
          item.section_level || '',
          item.extraction_index || ''
        ]);
      });
      
      const csvContent = csvRows.map(row => 
        row.map(cell => `"${cell}"`).join(',')
      ).join('\n');
      
      const blob = new Blob([csvContent], { type: 'text/csv' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'tree_structure.csv';
      a.click();
      URL.revokeObjectURL(url);
    }

    // Event listeners
    document.addEventListener('DOMContentLoaded', function() {
      byId('fileInput').addEventListener('change', async function(event) {
        const file = event.target.files[0];
        if (!file) return;
        
        try {
          console.log('Loading file:', file.name, 'Size:', file.size);
          const text = await file.text();
          console.log('File loaded, parsing JSON...');
          
          // Parse JSON with error handling
          let jsonData;
          try {
            jsonData = JSON.parse(text);
          } catch (parseError) {
            console.error('JSON parsing error:', parseError);
            alert('Error parsing JSON file: ' + parseError.message + '\n\nPlease check that the file contains valid JSON.');
            return;
          }
          
          console.log('JSON parsed successfully');
          processJSONData(jsonData);
          
        } catch (error) {
          console.error('File loading error:', error);
          if (error.message.includes('Maximum call stack size exceeded')) {
            alert('Error: The data structure contains circular references that cannot be displayed. This usually happens when items reference each other as parents, creating infinite loops.');
          } else {
            alert('Error loading file: ' + error.message);
          }
        }
      });
      
      byId('exportCsv').addEventListener('click', exportCsv);
      
      byId('reloadBtn').addEventListener('click', function() {
        if (treeData) {
          console.log('Reloading tree data...');
          // Clear any applied filters
          currentFilter = null;
          // Re-render the tree without re-processing data
          renderTree();
          // Reset any filter states
          showAll();
        } else {
          console.log('No tree data to reload');
        }
      });
      
      // Try to load default file
      fetch('annotated_extractions_single.json')
        .then(response => response.json())
        .then(data => processJSONData(data))
        .catch(() => {
          // Silently fail - user will need to select file manually
        });
    });
  </script>
</body>
</html>